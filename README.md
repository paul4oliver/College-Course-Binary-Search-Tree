# Reflection


During the projects for this course, I was asked to analyze different data structures for their effectiveness in facilitating the needs of a university’s academic advisors. To help with their programming needs, I outlined designs for implementations of a vector, hash table, and binary search tree by writing pseudocode to reflect the logic behind the code for each structure. From there, I analyzed their runtime and space complexity to determine the most efficient and appropriate data structure to use. It was obvious that fewer lines of code did not equate to a quicker runtime in the vector’s analysis and a hash table could not sort the data alphanumerically effectively. In my recommendation, I suggested a binary search tree because of its average runtime complexity of O(log(n)) for searching, inserting, and removing nodes.

Data structures are important to understand because they perform differently in different situations. Choosing the most appropriate one is not as simple as selecting the one that can perform all of the logic to meet the program requirements. A runtime analysis should be used to decide which structure can perform the program’s requirements the quickest and with the best use of space.

I used online resources like Stack Overflow and GitHub to overcome roadblocks I encountered while going through the activities and project. Taking a break from my work to clear my mind was also helpful. I feel that sometimes there are things you cannot quite see until you have stepped away for a couple of minutes and returned. My work on this project has expanded my approach to designing software and developing programs by giving me experience with different data structures and an understanding of the importance of comparing them before implementing them. They do not all perform the same for all programs and they can significantly impact performance. I have been further encouraged to take the time do the research and respect the design process. Additionally, this project evolved the way I write programs that are maintainable, readable, and adaptable because of the use of explicit functions and insightful comments. Future adaptations to make this more maintainable, readable, and adaptable could be to use abstraction to hide the binary search tree class and functions from the main CPP file.
